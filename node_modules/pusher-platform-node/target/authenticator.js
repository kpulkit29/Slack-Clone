"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var jwt = require("jsonwebtoken");
var common_1 = require("./common");
var DEFAULT_TOKEN_EXPIRY = 24 * 60 * 60;
var CLIENT_CREDENTIALS_GRANT_TYPE = 'client_credentials';
var REFRESH_TOKEN_GRANT_TYPE = 'refresh_token';
var Authenticator = (function () {
    function Authenticator(instanceId, instanceKeyId, instanceKeySecret, 
        // Customise token expiry
        tokenExpiry) {
        this.instanceId = instanceId;
        this.instanceKeyId = instanceKeyId;
        this.instanceKeySecret = instanceKeySecret;
        this.tokenExpiry = tokenExpiry;
        if (!this.tokenExpiry) {
            this.tokenExpiry = DEFAULT_TOKEN_EXPIRY;
        }
    }
    Authenticator.prototype.authenticate = function (authenticatePayload, options) {
        var grantType = authenticatePayload['grant_type'];
        if (grantType !== CLIENT_CREDENTIALS_GRANT_TYPE) {
            return new common_1.AuthenticationResponse({
                status: 422,
                body: {
                    error: 'token_provider/invalid_grant_type',
                    error_description: "The grant_type provided, " + grantType + ", is unsupported",
                }
            });
        }
        return this.authenticateUsingClientCredentials(options);
    };
    Authenticator.prototype.authenticateWithRefreshToken = function (authenticatePayload, options) {
        var grantType = authenticatePayload['grant_type'];
        switch (grantType) {
            case CLIENT_CREDENTIALS_GRANT_TYPE:
                return this.authenticateUsingClientCredentials(options, true);
            case REFRESH_TOKEN_GRANT_TYPE:
                var oldRefreshToken = authenticatePayload[REFRESH_TOKEN_GRANT_TYPE];
                return this.authenticateUsingRefreshToken(oldRefreshToken, options);
            default:
                return new common_1.AuthenticationResponse({
                    status: 422,
                    body: {
                        error: 'token_provider/invalid_grant_type',
                        error_description: "The grant_type provided, " + grantType + ", is unsupported",
                    }
                });
        }
    };
    Authenticator.prototype.authenticateUsingClientCredentials = function (options, withRefreshToken) {
        if (withRefreshToken === void 0) { withRefreshToken = false; }
        var token = this.generateAccessToken(options).token;
        var tokenExpiry = options.tokenExpiry || this.tokenExpiry;
        var body = {
            access_token: token,
            expires_in: tokenExpiry,
            token_type: 'bearer',
        };
        if (withRefreshToken) {
            var refreshToken = this.generateRefreshToken(options);
            body['refresh_token'] = refreshToken.token;
        }
        return new common_1.AuthenticationResponse({
            status: 200,
            body: body
        });
    };
    Authenticator.prototype.authenticateUsingRefreshToken = function (oldRefreshToken, options) {
        var decoded;
        var tokenExpiry = options.tokenExpiry || this.tokenExpiry;
        try {
            decoded = jwt.verify(oldRefreshToken, this.instanceKeySecret, {
                issuer: "api_keys/" + this.instanceKeyId,
            });
        }
        catch (e) {
            var description = (e instanceof jwt.TokenExpiredError) ? 'Refresh token has expired' : 'Refresh token is invalid';
            return new common_1.AuthenticationResponse({
                status: 401,
                body: {
                    error: 'token_provider/invalid_refresh_token',
                    error_description: description,
                }
            });
        }
        if (decoded.refresh !== true) {
            return new common_1.AuthenticationResponse({
                status: 401,
                body: {
                    error: 'token_provider/invalid_refresh_token',
                    error_description: 'Refresh token does not have a refresh claim',
                }
            });
        }
        if (options.userId !== decoded.sub) {
            return new common_1.AuthenticationResponse({
                status: 401,
                body: {
                    error: 'token_provider/invalid_refresh_token',
                    error_description: 'Refresh token has an invalid user id',
                }
            });
        }
        var newAccessToken = this.generateAccessToken(options);
        var newRefreshToken = this.generateRefreshToken(options);
        return new common_1.AuthenticationResponse({
            status: 200,
            body: {
                access_token: newAccessToken.token,
                token_type: 'bearer',
                expires_in: tokenExpiry,
                refresh_token: newRefreshToken.token,
            }
        });
    };
    Authenticator.prototype.generateAccessToken = function (options) {
        var now = Math.floor(Date.now() / 1000);
        var tokenExpiry = options.tokenExpiry || this.tokenExpiry;
        var claims = __assign({ instance: this.instanceId, iss: "api_keys/" + this.instanceKeyId, iat: now, exp: now + tokenExpiry, sub: options.userId, su: options.su }, options.serviceClaims);
        return {
            token: jwt.sign(claims, this.instanceKeySecret),
            expires_in: tokenExpiry,
        };
    };
    Authenticator.prototype.generateRefreshToken = function (options) {
        var now = Math.floor(Date.now() / 1000);
        var claims = {
            instance: this.instanceId,
            iss: "api_keys/" + this.instanceKeyId,
            iat: now,
            refresh: true,
            sub: options.userId,
        };
        return {
            token: jwt.sign(claims, this.instanceKeySecret),
        };
    };
    return Authenticator;
}());
exports.default = Authenticator;
//# sourceMappingURL=authenticator.js.map